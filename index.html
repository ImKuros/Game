<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Anny's Adventure - JS Platformer</title>
    <style>
        body {
            background-color: #202028;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            font-family: 'Courier New', Courier, monospace;
            color: white;
        }

        #game-container {
            position: relative;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            border: 4px solid #444;
        }

        canvas {
            background-color: #87CEEB; /* Cor do Céu */
            display: block;
            /* Garante visual pixel art nítido ao redimensionar */
            image-rendering: pixelated; 
        }

        #ui-layer {
            position: absolute;
            top: 10px;
            left: 10px;
            pointer-events: none;
            text-shadow: 2px 2px 0 #000;
            font-weight: bold;
            font-size: 18px;
        }

        #overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
        }
        
        .hidden { display: none !important; }
        
        h1 { font-size: 40px; margin: 0 0 20px 0; text-transform: uppercase; color: #FFD700; text-shadow: 4px 4px 0 #000; }
        p { margin-bottom: 30px; font-size: 18px; }
        button {
            padding: 15px 30px;
            font-size: 20px;
            font-family: inherit;
            background: #ff4d4d;
            border: 4px solid #fff;
            color: white;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 4px 4px 0 #000;
        }
        button:hover { background: #ff1a1a; margin-top: 2px; box-shadow: 2px 2px 0 #000; }
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas" width="640" height="360"></canvas>
        <div id="ui-layer">
            SCORE: <span id="scoreVal">0</span> | VIDAS: <span id="livesVal">3</span>
        </div>
        
        <div id="overlay">
            <h1 id="msg-title">ANNY'S ADVENTURE</h1>
            <p id="msg-desc">Use Setas ou WASD para Mover. Espaço para Pular.</p>
            <button id="btn-action" onclick="game.startGame()">JOGAR</button>
        </div>
    </div>

<script>
/**
 * ARQUITETURA E CONFIGURAÇÕES
 */
const TILE_SIZE = 32;
const GRAVITY = 0.6;
const FRICTION = 0.8;
const ACCEL = 0.5;
const MAX_SPEED = 6;
const JUMP_FORCE = 13;

// Mapeamento de Teclas
const KEYS = {
    LEFT: ['ArrowLeft', 'a', 'A'],
    RIGHT: ['ArrowRight', 'd', 'D'],
    JUMP: [' ', 'ArrowUp', 'w', 'W']
};

/**
 * SISTEMA DE INPUT
 */
class InputHandler {
    constructor() {
        this.keys = {};
        window.addEventListener('keydown', e => this.keys[e.key] = true);
        window.addEventListener('keyup', e => this.keys[e.key] = false);
    }

    isDown(keyArray) {
        return keyArray.some(k => this.keys[k]);
    }
}

/**
 * CLASSE MAPA (Tilemap)
 * 1 = Chão, 2 = Jogador Start, 3 = Inimigo, 4 = Final/Bandeira, 5 = Espinho/Morte
 */
class LevelMap {
    constructor() {
        // Criando um mapa longo via string para facilitar edição visual
        // W = Parede/Chão, P = Player, E = Inimigo, F = Final, S = Spikes (Morte)
        // . = Ar
        const mapString = [
            ".......................................................................................................................",
            ".......................................................................................................................",
            ".......................................................................................................................",
            ".......................................................................................................................",
            ".......................................................................................................................",
            ".......................................................................................................................",
            "...........................WWWW........................................................................................",
            "..........................WWWWWW.......................................................................F...............",
            ".........................WWWWWWWW.......E..................................E.........E.............WWWWWWWWWW..........",
            "........................WWWWWWWWWW...WWWWWW........WWWWWWW...............WWWWW.....WWWWWW..........WWWWWWWWWW..........",
            "P................E.....WWWWWWWWWWWW................................................................WWWWWWWWWW..........",
            "WWWWWWWWWW...WWWWWWWWWWWWWWWWWWWWWWWWWW......SSS...........SSS...WWWWWWW.......SSS........SSSSS....WWWWWWWWWW.........."
        ];
        
        this.tiles = [];
        this.entities = { playerStart: {x:0, y:0}, enemies: [], goal: null };
        this.width = mapString[0].length;
        this.height = mapString.length;

        this.parseMap(mapString);
    }

    parseMap(arr) {
        for (let y = 0; y < this.height; y++) {
            let row = [];
            for (let x = 0; x < this.width; x++) {
                const char = arr[y][x];
                let val = 0; // Ar
                
                if (char === 'W') val = 1;
                else if (char === 'S') val = 5;
                else if (char === 'P') this.entities.playerStart = {x: x * TILE_SIZE, y: y * TILE_SIZE};
                else if (char === 'E') this.entities.enemies.push({x: x * TILE_SIZE, y: y * TILE_SIZE});
                else if (char === 'F') this.entities.goal = {x: x * TILE_SIZE, y: y * TILE_SIZE};
                
                row.push(val);
            }
            this.tiles.push(row);
        }
    }

    getTile(col, row) {
        if (row < 0 || row >= this.height || col < 0 || col >= this.width) return 0;
        return this.tiles[row][col];
    }
}

/**
 * CLASSE ENTIDADE BASE
 */
class Entity {
    constructor(x, y, width, height, color) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.vx = 0;
        this.vy = 0;
        this.color = color;
        this.markedForDeletion = false;
    }

    draw(ctx, camX) {
        // Placeholder gráfico (Retângulo)
        ctx.fillStyle = this.color;
        ctx.fillRect(Math.floor(this.x - camX), Math.floor(this.y), this.width, this.height);
    }

    // Colisão AABB simples
    checkCollision(other) {
        return (
            this.x < other.x + other.width &&
            this.x + this.width > other.x &&
            this.y < other.y + other.height &&
            this.y + this.height > other.y
        );
    }
}

/**
 * JOGADOR (ANNY)
 */
class Player extends Entity {
    constructor(x, y) {
        super(x, y, 24, 30, '#ff4d4d'); // Vermelho (Anny)
        this.grounded = false;
        this.facingRight = true;
        this.state = 'idle'; // idle, run, jump
    }

    update(input, map, bounds) {
        // INPUT
        if (input.isDown(KEYS.LEFT)) {
            this.vx -= ACCEL;
            this.facingRight = false;
        }
        if (input.isDown(KEYS.RIGHT)) {
            this.vx += ACCEL;
            this.facingRight = true;
        }
        if (input.isDown(KEYS.JUMP) && this.grounded) {
            this.vy = -JUMP_FORCE;
            this.grounded = false;
        }

        // FÍSICA
        this.vx *= FRICTION;
        this.vy += GRAVITY;

        // Limite de velocidade
        if (this.vx > MAX_SPEED) this.vx = MAX_SPEED;
        if (this.vx < -MAX_SPEED) this.vx = -MAX_SPEED;

        // COLISÃO HORIZONTAL
        this.x += this.vx;
        this.handleMapCollision(map, 'x');

        // COLISÃO VERTICAL
        this.y += this.vy;
        this.grounded = false;
        this.handleMapCollision(map, 'y');

        // CAIR DO MUNDO
        if (this.y > bounds.height * TILE_SIZE + 100) {
            game.playerDied();
        }

        // ESTADOS VISUAIS (Para sprites futuros)
        if (!this.grounded) this.state = 'jump';
        else if (Math.abs(this.vx) > 0.5) this.state = 'run';
        else this.state = 'idle';
    }

    handleMapCollision(map, axis) {
        // Pontos de verificação (cantos da hitbox)
        const left = Math.floor(this.x / TILE_SIZE);
        const right = Math.floor((this.x + this.width - 0.1) / TILE_SIZE);
        const top = Math.floor(this.y / TILE_SIZE);
        const bottom = Math.floor((this.y + this.height - 0.1) / TILE_SIZE);

        // Verifica tiles sólidos (1 = parede)
        const tl = map.getTile(left, top);
        const tr = map.getTile(right, top);
        const bl = map.getTile(left, bottom);
        const br = map.getTile(right, bottom);

        // Verifica Morte Instantânea (5 = Espinho)
        if (tl === 5 || tr === 5 || bl === 5 || br === 5) {
            game.playerDied();
            return;
        }

        if (axis === 'x') {
            if ((tl === 1 || bl === 1) && this.vx < 0) {
                this.x = (left + 1) * TILE_SIZE;
                this.vx = 0;
            } else if ((tr === 1 || br === 1) && this.vx > 0) {
                this.x = right * TILE_SIZE - this.width;
                this.vx = 0;
            }
        }

        if (axis === 'y') {
            if ((tl === 1 || tr === 1) && this.vy < 0) { // Cabeça bateu
                this.y = (top + 1) * TILE_SIZE;
                this.vy = 0;
            } else if ((bl === 1 || br === 1) && this.vy > 0) { // Aterrissou
                this.y = bottom * TILE_SIZE - this.height;
                this.vy = 0;
                this.grounded = true;
                
                // Spawnar partículas de poeira ao cair (Juice!)
                if (this.vy > 5) game.spawnParticles(this.x + this.width/2, this.y + this.height, '#fff', 3);
            }
        }
    }

    draw(ctx, camX) {
        // Sobrescrevendo o draw para simular animação
        ctx.fillStyle = this.color;
        let h = this.height;
        let w = this.width;
        let y = this.y;

        // Efeito de "Squash & Stretch" simples
        if (this.state === 'jump') { h += 2; w -= 2; }
        if (this.state === 'run') { 
            // Pequeno bobbing ao correr
            if (Math.floor(Date.now() / 100) % 2 === 0) y -= 2; 
        }

        ctx.fillRect(Math.floor(this.x - camX), Math.floor(y), w, h);
        
        // Olhos (para saber direção)
        ctx.fillStyle = 'white';
        let eyeOffset = this.facingRight ? 14 : 4;
        ctx.fillRect(Math.floor(this.x - camX + eyeOffset), Math.floor(y + 6), 4, 4);
    }
}

/**
 * INIMIGO (GOOMBA)
 */
class Enemy extends Entity {
    constructor(x, y) {
        super(x, y, 32, 32, '#8b00ff'); // Roxo
        this.vx = -2; // Começa andando pra esquerda
        this.patrolStart = x;
    }

    update(map) {
        this.vy += GRAVITY;
        this.x += this.vx;
        this.y += this.vy;

        // Colisão simples com chão e inversão de direção
        const left = Math.floor(this.x / TILE_SIZE);
        const right = Math.floor((this.x + this.width) / TILE_SIZE);
        const bottom = Math.floor((this.y + this.height) / TILE_SIZE);
        
        // Verifica paredes laterais
        const wallL = map.getTile(left, Math.floor(this.y/TILE_SIZE)) === 1;
        const wallR = map.getTile(right, Math.floor(this.y/TILE_SIZE)) === 1;

        // Verifica se tem chão logo a frente (para não cair)
        const groundL = map.getTile(left, bottom) === 1;
        const groundR = map.getTile(right, bottom) === 1;

        if (this.y % TILE_SIZE < 5) { // Alinhamento vertical simples
             this.y = (bottom - 1) * TILE_SIZE;
             this.vy = 0;
        }
        
        // Lógica de Patrulha IA
        if (wallL || (!groundL && this.vx < 0)) this.vx = 2;
        if (wallR || (!groundR && this.vx > 0)) this.vx = -2;
    }
}

/**
 * PARTÍCULAS (Efeitos Visuais)
 */
class Particle extends Entity {
    constructor(x, y, color) {
        super(x, y, 4, 4, color);
        this.vx = (Math.random() - 0.5) * 10;
        this.vy = (Math.random() - 0.5) * 10;
        this.life = 1.0; // Opacidade
    }
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life -= 0.05;
        if (this.life <= 0) this.markedForDeletion = true;
    }
    draw(ctx, camX) {
        ctx.fillStyle = this.color;
        ctx.globalAlpha = this.life;
        ctx.fillRect(this.x - camX, this.y, this.width, this.height);
        ctx.globalAlpha = 1.0;
    }
}

/**
 * MOTOR DO JOGO (GAME LOOP)
 */
class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.input = new InputHandler();
        
        this.scoreElem = document.getElementById('scoreVal');
        this.livesElem = document.getElementById('livesVal');
        this.overlay = document.getElementById('overlay');
        this.msgTitle = document.getElementById('msg-title');
        this.msgDesc = document.getElementById('msg-desc');
        this.btnAction = document.getElementById('btn-action');

        this.lives = 3;
        this.score = 0;
        this.isRunning = false;
    }

    resetLevel() {
        this.map = new LevelMap();
        this.player = new Player(this.map.entities.playerStart.x, this.map.entities.playerStart.y);
        
        this.enemies = this.map.entities.enemies.map(e => new Enemy(e.x, e.y));
        this.particles = [];
        this.cameraX = 0;
        
        // Objeto Bandeira (Final)
        this.goal = {
            x: this.map.entities.goal.x, 
            y: this.map.entities.goal.y, 
            width: 32, height: 32, active: true 
        };
    }

    startGame() {
        this.lives = 3;
        this.score = 0;
        this.updateUI();
        this.resetLevel();
        this.overlay.classList.add('hidden');
        this.isRunning = true;
        this.loop();
    }

    playerDied() {
        this.spawnParticles(this.player.x, this.player.y, '#ff4d4d', 20);
        this.lives--;
        this.updateUI();

        if (this.lives < 0) {
            this.gameOver();
        } else {
            // Respawn
            this.player.x = this.map.entities.playerStart.x;
            this.player.y = this.map.entities.playerStart.y;
            this.player.vx = 0;
            this.player.vy = 0;
        }
    }

    gameOver() {
        this.isRunning = false;
        this.msgTitle.innerText = "GAME OVER";
        this.msgDesc.innerText = `Você fez ${this.score} pontos. Tente de novo!`;
        this.btnAction.innerText = "REINICIAR";
        this.btnAction.onclick = () => this.startGame();
        this.overlay.classList.remove('hidden');
    }

    gameWin() {
        this.isRunning = false;
        this.msgTitle.innerText = "FASES CONCLUÍDAS!";
        this.msgTitle.style.color = "#4dff4d";
        this.msgDesc.innerText = `Parabéns! Pontuação final: ${this.score}`;
        this.btnAction.innerText = "JOGAR NOVAMENTE";
        this.btnAction.onclick = () => this.startGame();
        this.overlay.classList.remove('hidden');
    }

    spawnParticles(x, y, color, count) {
        for(let i=0; i<count; i++) {
            this.particles.push(new Particle(x, y, color));
        }
    }

    updateUI() {
        this.scoreElem.innerText = this.score;
        this.livesElem.innerText = Math.max(0, this.lives);
    }

    update() {
        if (!this.isRunning) return;

        // Player
        this.player.update(this.input, this.map, this.canvas);

        // Câmera (Segue o player com "lerp" suave)
        let targetCamX = this.player.x - this.canvas.width / 2;
        // Clamp (não sair do mapa)
        targetCamX = Math.max(0, Math.min(targetCamX, this.map.width * TILE_SIZE - this.canvas.width));
        this.cameraX += (targetCamX - this.cameraX) * 0.1; // Suavização

        // Inimigos
        this.enemies.forEach(enemy => {
            enemy.update(this.map);
            
            // Colisão Player vs Inimigo
            if (this.player.checkCollision(enemy) && !enemy.markedForDeletion) {
                // Checar se pulou na cabeça (Player está caindo e acima do inimigo)
                const hitFromTop = (this.player.y + this.player.height) - enemy.y < 10 && this.player.vy > 0;
                
                if (hitFromTop) {
                    // Mata inimigo
                    enemy.markedForDeletion = true;
                    this.player.vy = -JUMP_FORCE * 0.6; // Pulinho rebote
                    this.score += 100;
                    this.updateUI();
                    this.spawnParticles(enemy.x, enemy.y, '#8b00ff', 10);
                } else {
                    // Mata player
                    this.playerDied();
                }
            }
        });

        // Limpar Inimigos mortos
        this.enemies = this.enemies.filter(e => !e.markedForDeletion);

        // Partículas
        this.particles.forEach(p => p.update());
        this.particles = this.particles.filter(p => !p.markedForDeletion);

        // Checar Vitória
        if (this.player.checkCollision(this.goal)) {
            this.gameWin();
        }
    }

    draw() {
        // Limpar tela
        this.ctx.fillStyle = '#87CEEB';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Desenhar Tiles
        for (let y = 0; y < this.map.height; y++) {
            for (let x = 0; x < this.map.width; x++) {
                let tile = this.map.tiles[y][x];
                let tileX = Math.floor(x * TILE_SIZE - this.cameraX);
                let tileY = y * TILE_SIZE;

                // Otimização: Só desenha o que está na tela
                if (tileX < -TILE_SIZE || tileX > this.canvas.width) continue;

                if (tile === 1) {
                    this.ctx.fillStyle = '#44aa44'; // Grama
                    this.ctx.fillRect(tileX, tileY, TILE_SIZE, TILE_SIZE);
                    // Detalhe pixel art simples
                    this.ctx.fillStyle = '#2d862d';
                    this.ctx.fillRect(tileX + 4, tileY + 4, TILE_SIZE - 8, TILE_SIZE - 8);
                } else if (tile === 5) {
                    this.ctx.fillStyle = '#ff0000'; // Espinho
                    this.ctx.beginPath();
                    this.ctx.moveTo(tileX, tileY + TILE_SIZE);
                    this.ctx.lineTo(tileX + TILE_SIZE/2, tileY);
                    this.ctx.lineTo(tileX + TILE_SIZE, tileY + TILE_SIZE);
                    this.ctx.fill();
                }
            }
        }

        // Desenhar Bandeira
        this.ctx.fillStyle = '#FFD700';
        this.ctx.fillRect(this.goal.x - this.cameraX, this.goal.y, 10, 32);
        this.ctx.fillStyle = 'red';
        this.ctx.fillRect(this.goal.x + 10 - this.cameraX, this.goal.y, 20, 15);

        // Entidades
        this.enemies.forEach(e => e.draw(this.ctx, this.cameraX));
        this.player.draw(this.ctx, this.cameraX);
        this.particles.forEach(p => p.draw(this.ctx, this.cameraX));
    }

    loop() {
        if (!this.isRunning) return;
        this.update();
        this.draw();
        requestAnimationFrame(() => this.loop());
    }
}

// Inicialização
const game = new Game();
</script>
</body>
</html>
